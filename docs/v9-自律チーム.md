# v9: 自律チーム

**コアの洞察: 真に有能なチームは命令を待たない -- 自ら仕事を見つける。**

v8で受信箱を通じて通信し、タスクボードを共有する持続的なエージェント、Teammateを手に入れた。しかしv8のTeammateは受動的で、初期プロンプトを実行し、メッセージを確認し、作業がなければシャットダウンする。自律的に新しい作業を引き受けることはない。

v9が追加する欠けていたピース: **Teammateの自律性**。Teammateは作業完了後にアイドル状態に入り、新しいメッセージや未割当タスクをポーリングし、何かを見つけたら起動する。チームが自己組織化する。

## v8 vs v9 ループ比較

```
v8 Teammate Loop:                    v9 Teammate Loop:
+-------+                           +-------+
| spawn |                           | spawn |
+---+---+                           +---+---+
    |                                    |
    v                                    v
+--------+                          +--------+
| WORK   | <-- tool_use loop        | WORK   | <-- tool_use loop
+---+----+                          +---+----+
    |                                    |
    | stop_reason != tool_use            | stop_reason != tool_use
    v                                    v
+--------+                          +--------+
| check  |                          | IDLE   |  <-- 1秒ポーリング x 60回 (cli.js cZz=1000ms)
| inbox  |                          | phase  |
+---+----+                          +---+----+
    |                                    |
    +-> new msg? -> resume               +-> inbox msg? -> resume WORK
    |                                    +-> unclaimed task? -> claim -> WORK
    +-> nothing? -> EXIT                 +-> 60s timeout? -> restart idle
                                         +-> shutdown? -> EXIT
```

v8: 作業が終わったら終了。v9: 作業が終わったらアイドル状態に移行し、新しい仕事を探す。

## v9がv8に追加するもの

| 機能 | v8（チーム通信） | v9（自律チーム） |
|------|-----------------|-----------------|
| Teammateループ | 作業後に終了 | 作業 -> アイドル -> 起動 -> 作業 |
| タスク割当 | なし（Leadが割り当て） | 未割当タスクを自動割当 |
| アイドルサイクル | なし | 1秒ポーリング、60秒タイムアウト |
| アイデンティティ保持 | なし | 圧縮後に再注入 |
| 計画承認 | スタブ | 完全なプロトコルサポート |

## 自律Teammateライフサイクル

Teammateのライフサイクルは継続的な `active -> idle -> active` サイクルになる:

```
+-------+
| spawn |
+---+---+
    |
    v
+-------+    tool_use     +---------+
| WORK  | <------------- | API call |
| phase |                 +---------+
+---+---+
    |
    | stop_reason != tool_use
    v
+--------+
| IDLE   |  <-- 1秒ごとにポーリング (cli.js cZz=1000ms)
| phase  |      60秒間
+---+----+
    |
    +-------> 受信箱を確認
    |         - shutdown_request? -> 終了
    |         - plan_approval?    -> 承認処理
    |         - 新メッセージ?      -> WORKに復帰
    |
    +-------> 未割当タスクをスキャン
    |         - 発見? -> タスクを割当 -> WORKに復帰
    |
    +-------> タイムアウト（活動なし）?
    |         -> 続行 (再チェック、最大60秒)
    |
    +-------> 60秒間新しい作業なし?
              -> シャットダウン (優雅な終了)
```

**active**フェーズでは、Teammateは通常のエージェントループ（API呼び出し -> ツール使用 -> API呼び出し）を実行する。モデルがツール呼び出しを停止（`stop_reason != "tool_use"`）すると、**idle**に遷移。

**idle**フェーズでは、Teammateは1秒ごとに最大60秒間受信箱をポーリング:
1. **新メッセージ**が到着したら、コンテキストに注入してactiveに戻る
2. タスクボードで**未割当タスク**（status=pending、ownerなし、blockerなし）を発見したら、自動割当してactiveに戻る
3. **shutdown_request**を受信したら、ループを完全に終了
4. 60秒間何も起きなければ、idleポーリングサイクルを再開

## 完全なTeammateループ

```python
def _teammate_loop(self, teammate, initial_prompt):
    sub_system = f"You are teammate '{teammate.name}' in team '{teammate.team_name}'..."
    sub_messages = [{"role": "user", "content": initial_prompt}]

    while teammate.status != "shutdown":
        # === Activeフェーズ: 通常のAgent Loop ===
        teammate.status = "active"

        sub_messages = CTX.microcompact(sub_messages)
        if CTX.should_compact(sub_messages):
            sub_messages = CTX.auto_compact(sub_messages)
            # 圧縮後にアイデンティティを再注入
            identity = f"\n\nRemember: You are teammate '{teammate.name}' in team '{teammate.team_name}'."
            sub_messages[0]["content"] += identity

        response = client.messages.create(...)

        if response.stop_reason == "tool_use":
            # ツールを実行して続行
            continue

        # === Idleフェーズ: 新メッセージまたは未割当タスクを待つ ===
        teammate.status = "idle"

        for _ in range(60):  # 1秒ごとにチェック、合計60秒
            if teammate.status == "shutdown":
                return

            new_messages = self.check_inbox(teammate.name, teammate.team_name)
            if new_messages:
                if any(m.get("type") == "shutdown_request" for m in new_messages):
                    return
                sub_messages.append({"role": "user", "content": format(new_messages)})
                break

            # 未割当タスクを自動割当
            unclaimed = [t for t in TASK_MGR.list_all()
                         if t.status == "pending" and not t.owner and not t.blocked_by]
            if unclaimed:
                TASK_MGR.update(unclaimed[0].id, status="in_progress", owner=teammate.name)
                sub_messages.append({
                    "role": "user",
                    "content": f"Task #{unclaimed[0].id}: ..."
                })
                break

            time.sleep(1)
```

## タスクの自動割当

Teammateは共有タスクボードから自律的に作業を割り当てる:

```python
unclaimed = [t for t in TASK_MGR.list_all()
             if t.status == "pending" and not t.owner and not t.blocked_by]
if unclaimed:
    task = unclaimed[0]
    TASK_MGR.update(task.id, status="in_progress", owner=teammate.name)
```

割当は先着順（タスクIDでソート）。`TaskManager.update()` のスレッドロックが、複数のTeammateが同じタスクを同時に割当しようとした際の競合状態を防ぐ。

Team Leadが事前にタスクをまとめて作成すれば、Teammateは依存関係が解消されたタスクを自動的に引き受ける。明示的な割り当ては不要。

## コンテキスト圧縮時のアイデンティティ保持

Teammateのコンテキストが圧縮（v5 auto_compact）された場合、圧縮後のサマリーにはTeammateの身元が含まれない。Teammateループがアイデンティティを再注入する:

```python
if CTX.should_compact(sub_messages):
    sub_messages = CTX.auto_compact(sub_messages)
    identity = f"\n\nRemember: You are teammate '{teammate.name}' in team '{teammate.team_name}'."
    sub_messages[0]["content"] += identity
```

これにより、積極的なコンテキスト圧縮後でもモデルが自身の役割とチームのコンテキストを保持する。

## 完全な協力フロー

```sh
ユーザー: "アプリをRESTからGraphQLに移行して"

Team Lead:
  1. TeamCreate("rest-to-graphql")
  2. TaskCreate("Analyze REST endpoints")          -> #1
  3. TaskCreate("Design GraphQL schema")           -> #2, blockedBy=#1
  4. TaskCreate("Implement resolvers")             -> #3, blockedBy=#2
  5. TaskCreate("Update frontend")                 -> #4, blockedBy=#3

  6. Task(name="analyst", team_name=..., prompt="REST分析")
  7. Task(name="backend", team_name=..., prompt="バックエンド処理")
  8. Task(name="frontend", team_name=..., prompt="フロントエンド移行")

analyst:   #1を割当 -> 完了 -> idle -> (タスクなし) -> idleを継続
backend:   idle... <- #2解除 -> #2を割当 -> 完了 -> #3を割当 -> 完了 -> idle
frontend:  idle... <- #4解除 -> #4を割当 -> 完了 -> idle

Team Lead: 全タスク完了 -> TeamDelete -> "移行完了。"
```

4つの仕組みが連動:
- **Tasks (v6)** は共有カンバンボード。全員が同じ進捗を見る
- **圧縮 (v5)** が各メンバーの長時間作業を可能にする
- **メッセージプロトコル (v8)** でメンバー間がいつでも通信できる
- **自律性 (v9)** でTeammateが自己組織化。マイクロマネジメント不要

## v0からv9: 完全なストーリー

```sh
v0: 1つのエージェント、1つのツール
v1: 1つのエージェント、複数のツール
v2: 1つのエージェント、計画あり
v3: 1つのエージェント、作業員を派遣できる
v4: 1つのエージェント、ドメイン知識あり
v5: 1つのエージェント、忘れて作業を続けられる
v6: 複数のエージェント、共有ボードあり
v7: 複数のエージェント、並列で作業
v8: 複数のエージェント、通信する
v9: 複数のエージェント、自己組織化する
```

各ステップが前のステップで露呈したボトルネックを解決する。v9は集大成であり、エージェント協力の基本要素がすべて揃う: **共有状態（Tasks）+ 並列実行（Background）+ 通信（Messages）+ 自律性（アイドルサイクル + 自動割当）**。

## より深い洞察

> **自ら管理するチーム。**

v8のTeammateは同僚: 通信し、ボードを共有し、並列で作業する。しかしまだ明示的な指示を待つ。v9のTeammateは自律的: 未割当の作業を見つけ、割り当て、実行し、待機状態に戻る。Team Leadが方向を設定しタスクを作成すれば、Teammateが自己組織化して完了する。

```sh
v8 Teammate -> 割り当てられた作業を実行し、結果を通信（ジュニア）
v9 Teammate -> 仕事を見つけ、割り当て、実行し、待機（シニア）
Team Lead   -> タスクを分解し、レビューし、調整する（マネージャー）
```

エージェントシステムの究極形態は、より賢い単一モデルではなく、**協力し自己組織化できるモデルの集団**。

---

**1つのエージェントの能力には限界がある。自律エージェントの集団には限界がない。**

[← v8](./v8-チーム通信.md) | [READMEに戻る](../README_ja.md)
