# v4: スキル機構

**コアの洞察: スキルはツールではなく、知識パッケージ。**

## 問題

v3でタスク分解のためのサブエージェントを得た。しかしより深い問題がある：**モデルはドメイン固有のタスクをどのように処理するか知っているのか？**

- PDFを処理？`pdftotext` vs `PyMuPDF`を知る必要がある
- MCPサーバーを構築？プロトコル仕様とベストプラクティスが必要
- コードレビュー？体系的なチェックリストが必要

この知識はツールではない--**専門知識**だ。スキルはモデルがオンデマンドでドメイン知識を読み込むことで解決。

## 重要な概念

### ツール vs スキル

| 概念 | 何か | 例 |
|------|------|-----|
| **ツール** | モデルが何をCAN DO | bash, read_file, write_file |
| **スキル** | モデルがどうKNOW TO DO | PDF処理、MCP構築 |

ツールは能力。スキルは知識。

### 知識の外部化: トレーニングから編集へ

従来のモデル動作変更にはトレーニングが必要：GPUクラスタ + データ + ML専門知識。スキルはすべてを変える：

```
モデル動作の変更 = SKILL.mdの編集 = テキストファイルの編集 = 誰でもできる
```

| レイヤー | 変更方法 | 有効化時間 | コスト |
|---------|---------|-----------|--------|
| モデルパラメータ | トレーニング/ファインチューニング | 数時間-数日 | $10K-$1M+ |
| コンテキストウィンドウ | API呼び出し | 即座 | ~$0.01/call |
| **スキルライブラリ** | **SKILL.mdを編集** | **次のトリガー** | **無料** |

これは「AIのトレーニング」から「AIの教育」へのパラダイムシフト。

### 段階的開示

```
Layer 1: メタデータ（常にロード）    ~100 tokens/skill
         name + description

Layer 2: SKILL.mdボディ（トリガー時） ~2000 tokens
         詳細な手順

Layer 3: リソース（必要時）          無制限
         scripts/, references/, assets/
```

コンテキストを軽量に保ちつつ、任意の深さの知識を提供。

### SKILL.md標準

```
skills/
+-- pdf/
|   +-- SKILL.md          # 必須
+-- mcp-builder/
|   +-- SKILL.md
|   +-- references/       # オプション
+-- code-review/
    +-- SKILL.md
    +-- scripts/          # オプション
```

**フォーマット**: YAMLフロントマター + Markdownボディ

```md
---
name: pdf
description: PDFファイルを処理。PDF読み込み、作成、マージ時に使用。
---

# PDF処理スキル

## PDFの読み込み
高速抽出にはpdftotext使用：
pdftotext input.pdf -
```

## SKILL.mdロードフロー

```
ユーザー: "/pdf input.pdf を読んで"
         |
         v
+------------------+
| System Prompt    |  <-- Layer 1: スキルメタデータ（常に含まれる）
| "Available:      |      "- pdf: PDFファイルを処理..."
|  - pdf: ..."     |
+--------+---------+
         |
         v  モデルが Skill("pdf") を呼び出す
+------------------+
| SkillLoader      |  <-- Layer 2: SKILL.mdボディをロード
| parse_skill_md() |
+--------+---------+
         |
         v
+------------------+
| tool_result      |  <-- スキル内容を tool_result として注入
| <skill-loaded>   |      (system prompt は変更しない = キャッシュ保持)
| # PDF Processing |
| ## Reading PDFs  |
| pdftotext ...    |
| </skill-loaded>  |
+------------------+
         |
         v
モデルがスキルの指示に従って作業
```

## 実装（約100行追加）

### SkillLoaderクラス

```python
class SkillLoader:
    def __init__(self, skills_dir: Path):
        self.skills = {}
        self.load_skills()

    def parse_skill_md(self, path: Path) -> dict:
        """YAMLフロントマター + Markdownボディをパース。"""
        content = path.read_text()
        match = re.match(r'^---\s*\n(.*?)\n---\s*\n(.*)$', content, re.DOTALL)
        # {name, description, body, path, dir}を返す

    def get_descriptions(self) -> str:
        """システムプロンプト用のメタデータを生成。"""
        return "\n".join(f"- {name}: {skill['description']}"
                        for name, skill in self.skills.items())

    def get_skill_content(self, name: str) -> str:
        """コンテキスト注入用のフルコンテンツを取得。"""
        return f"# Skill: {name}\n\n{skill['body']}"
```

### Skillツール

```python
SKILL_TOOL = {
    "name": "Skill",
    "description": "専門知識を得るためにスキルを読み込む。",
    "input_schema": {
        "properties": {"skill": {"type": "string"}},
        "required": ["skill"]
    }
}
```

### メッセージ注入（キャッシュ保持）

重要な洞察: スキルコンテンツは**tool_result**（userメッセージの一部）に入る、システムプロンプトではない：

```python
def run_skill(skill_name: str) -> str:
    content = SKILLS.get_skill_content(skill_name)
    return f"""<skill-loaded name="{skill_name}">
{content}
</skill-loaded>

上記のスキルの指示に従ってください。"""
```

**なぜこれが重要か**:
- スキルコンテンツは新しいメッセージとして**末尾に追加**
- 前のすべて（システムプロンプト + すべての以前のメッセージ）はキャッシュされ再利用
- 新しく追加されたスキルコンテンツのみ計算が必要--**プレフィックス全体がキャッシュヒット**

> **コンテキストを追記専用ログとして扱い、編集可能なドキュメントとして扱わない。**

## 本番環境との比較

| 仕組み | Claude Code / Kode | v4 |
|--------|-------------------|-----|
| フォーマット | SKILL.md (YAML + MD) | 同じ |
| トリガー | 自動 + Skillツール | Skillツールのみ |
| 注入先 | newMessages (userメッセージ) | tool_result (userメッセージ) |
| キャッシュ | 末尾に追加、プレフィックス全体がキャッシュ | 末尾に追加、プレフィックス全体がキャッシュ |

## 設計思想

> **知識はファーストクラスのリソース**

スキルは**ドメイン知識自体がリソースとして明示的な管理を必要とする**ことを認める。

1. **メタデータとコンテンツの分離**: descriptionはインデックス、bodyはコンテンツ
2. **オンデマンドロード**: コンテキストウィンドウは貴重な認知リソース
3. **標準化フォーマット**: 一度書けば、互換性のある任意のエージェントで使用可能
4. **注入、返却ではない**: スキルは認知を変える、データを提供するだけではない

知識の外部化の本質は**暗黙知を明示的なドキュメントにする**こと。開発者が自然言語でモデルに新しいスキルを「教え」、Gitがバージョン管理とロールバックで知識を管理・共有する。

## シリーズサマリー

| バージョン | テーマ | 追加行数 | 重要な洞察 |
|-----------|--------|---------|-----------|
| v1 | モデルがエージェント | ~200 | モデルが80%、コードはループだけ |
| v2 | 構造化プランニング | ~100 | Todoが計画を可視化する |
| v3 | 分割統治 | ~150 | サブエージェントがコンテキストを分離 |
| **v4** | **ドメインエキスパート** | **~100** | **スキルが専門知識を注入** |

## Hookイベント

本番環境のシステムは15種類のhookイベントタイプをサポートする（PreToolUse, PostToolUse,
PostToolUseFailure, Notification, UserPromptSubmit, SessionStart, SessionEnd,
Stop, SubagentStart, SubagentStop, PreCompact, PermissionRequest, Setup,
TeammateIdle, TaskCompleted）。我々の実装はコアのPreToolUseと
PostToolUseパターンに焦点を当てる。Hookは特定のイベントに応答して実行される
シェルコマンドであり、コアコードの変更なしに拡張性を実現する。

---

**ツールはモデルに行動させる。スキルはモデルに知らせる。**

[← v3](./v3-サブエージェント.md) | [READMEに戻る](../README_ja.md) | [v5 →](./v5-コンテキスト圧縮.md)
