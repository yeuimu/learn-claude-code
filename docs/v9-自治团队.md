# v9: 自治团队

**核心洞察：真正有能力的团队不等命令——它自己找活干。**

v8 给了我们 Teammate：通过邮箱通信、共享任务看板的持久化代理。但 v8 的 Teammate 是被动的——它们执行初始提示词，检查消息，没有更多工作就关闭。它们不会自主地接手新任务。

v9 补上了缺失的一环：**Teammate 自治**。Teammate 在工作完成后进入空闲状态，轮询新消息和未认领的任务，发现工作就唤醒。团队变成自组织的。

## v9 相对 v8 新增了什么

| 特性 | v8（团队通信） | v9（自治团队） |
|------|---------------|---------------|
| Teammate 循环 | 工作后退出 | 工作 -> 空闲 -> 唤醒 -> 工作 |
| 任务认领 | 无（Lead 分配） | 自动认领未分配任务 |
| 空闲循环 | 无 | 每 1 秒轮询，60 秒超时 |
| 身份保持 | 无 | 压缩后重新注入 |
| 计划审批 | 存根 | 完整协议支持 |

## 自治 Teammate 生命周期

Teammate 的生命周期变成持续的 `active -> idle -> active` 循环：

```
+-------+
| spawn |
+---+---+
    |
    v
+-------+    tool_use     +---------+
| WORK  | <------------- | API call |
| phase |                 +---------+
+---+---+
    |
    | stop_reason != tool_use
    v
+--------+
| IDLE   |  <-- 每 1 秒轮询 (cli.js cZz=1000ms)
| phase  |      持续 60 秒
+---+----+
    |
    +-------> 检查收件箱
    |         - shutdown_request? -> 退出
    |         - plan_approval?    -> 处理审批
    |         - 新消息?           -> 恢复 WORK
    |
    +-------> 扫描未认领任务
    |         - 找到? -> 认领任务 -> 恢复 WORK
    |
    +-------> 超时无活动?
    |         -> 继续 (再次检查, 最长 60 秒)
    |
    +-------> 60 秒内无新工作?
              -> 关闭 (优雅退出)
```

在 **active** 阶段，Teammate 运行正常的 Agent 循环（API 调用 -> 工具使用 -> API 调用）。当模型停止调用工具（`stop_reason != "tool_use"`）时，转入 **idle**。

在 **idle** 阶段，Teammate 每 1 秒轮询一次收件箱，持续最多 60 秒：
1. 如果**新消息**到达，注入上下文并返回 active
2. 如果在任务看板上发现**未认领任务**（status=pending，无 owner，无 blocker），自动认领并返回 active
3. 如果收到 **shutdown_request**，完全退出循环
4. 如果 60 秒内无事发生，重新开始 idle 轮询循环

## 完整的 Teammate 循环

```python
def _teammate_loop(self, teammate, initial_prompt):
    sub_system = f"You are teammate '{teammate.name}' in team '{teammate.team_name}'..."
    sub_messages = [{"role": "user", "content": initial_prompt}]

    while teammate.status != "shutdown":
        # === Active 阶段: 正常 Agent Loop ===
        teammate.status = "active"

        sub_messages = CTX.microcompact(sub_messages)
        if CTX.should_compact(sub_messages):
            sub_messages = CTX.auto_compact(sub_messages)
            # 压缩后重新注入身份
            identity = f"\n\nRemember: You are teammate '{teammate.name}' in team '{teammate.team_name}'."
            sub_messages[0]["content"] += identity

        response = client.messages.create(...)

        if response.stop_reason == "tool_use":
            # 执行工具并继续
            continue

        # === Idle 阶段: 等待新消息或新任务 ===
        teammate.status = "idle"

        for _ in range(60):  # 每 1 秒检查一次, 共 60 秒
            if teammate.status == "shutdown":
                return

            new_messages = self.check_inbox(teammate.name, teammate.team_name)
            if new_messages:
                if any(m.get("type") == "shutdown_request" for m in new_messages):
                    return
                sub_messages.append({"role": "user", "content": format(new_messages)})
                break

            # 自动认领未分配任务
            unclaimed = [t for t in TASK_MGR.list_all()
                         if t.status == "pending" and not t.owner and not t.blocked_by]
            if unclaimed:
                TASK_MGR.update(unclaimed[0].id, status="in_progress", owner=teammate.name)
                sub_messages.append({
                    "role": "user",
                    "content": f"Task #{unclaimed[0].id}: ..."
                })
                break

            time.sleep(1)
```

## 任务自动认领

Teammate 自主从共享任务看板认领工作：

```python
unclaimed = [t for t in TASK_MGR.list_all()
             if t.status == "pending" and not t.owner and not t.blocked_by]
if unclaimed:
    task = unclaimed[0]
    TASK_MGR.update(task.id, status="in_progress", owner=teammate.name)
```

认领遵循先到先得顺序（按任务 ID 排序）。`TaskManager.update()` 中的线程锁防止多个 Teammate 同时认领同一任务时的竞态条件。

这意味着 Team Lead 可以预先批量创建任务，Teammate 会在任务可用时（依赖解除后）自动接手。不需要显式分配。

## 上下文压缩身份保持

当 Teammate 的上下文被压缩（v5 auto_compact）后，压缩后的摘要不会保留 Teammate 的身份。Teammate 循环会重新注入身份信息：

```python
if CTX.should_compact(sub_messages):
    sub_messages = CTX.auto_compact(sub_messages)
    identity = f"\n\nRemember: You are teammate '{teammate.name}' in team '{teammate.team_name}'."
    sub_messages[0]["content"] += identity
```

这确保模型即使在激进的上下文压缩后仍能保持其角色和团队上下文。没有这个机制，Teammate 在 auto_compact 后可能会"忘记"自己属于某个团队，开始表现得像独立代理。

## 完整协作流程

```sh
用户: "把应用从 REST 迁移到 GraphQL"

Team Lead:
  1. TeamCreate("rest-to-graphql")
  2. TaskCreate("Analyze REST endpoints")          -> #1
  3. TaskCreate("Design GraphQL schema")           -> #2, blockedBy=#1
  4. TaskCreate("Implement resolvers")             -> #3, blockedBy=#2
  5. TaskCreate("Update frontend")                 -> #4, blockedBy=#3

  6. Task(name="analyst", team_name=..., prompt="分析 REST 端点")
  7. Task(name="backend", team_name=..., prompt="处理后端任务")
  8. Task(name="frontend", team_name=..., prompt="处理前端迁移")

analyst:   认领 #1 -> 完成 -> idle -> (无更多任务) -> 保持 idle
backend:   idle... <- #2 解锁 -> 认领 #2 -> 完成 -> 认领 #3 -> 完成 -> idle
frontend:  idle... <- #4 解锁 -> 认领 #4 -> 完成 -> idle

Team Lead: 所有任务完成 -> TeamDelete -> "迁移完成。"
```

四个机制联动：
- **Tasks (v6)** 是共享看板——所有人看到同一个进度
- **压缩 (v5)** 让每个角色长时间工作——不受上下文限制
- **消息协议 (v8)** 让角色间随时沟通
- **自治 (v9)** 让 Teammate 自组织——不需要微管理

## 计划审批协议

v9 完整支持 `plan_approval_response` 消息类型。当 Teammate 需要对重大变更获得批准时：

1. Teammate 通过 `SendMessage` 向 Team Lead 发送计划详情
2. Team Lead 审核后发送 `plan_approval_response`，`approve=true/false`
3. Teammate 在邮箱中读取响应，继续执行（或修改方案）

## v0 到 v9：完整的故事

```sh
v0: 一个 Agent, 一个工具
v1: 一个 Agent, 多个工具
v2: 一个 Agent, 有计划
v3: 一个 Agent, 能派人
v4: 一个 Agent, 有知识
v5: 一个 Agent, 能遗忘
v6: 多个 Agent, 有看板
v7: 多个 Agent, 能并行
v8: 多个 Agent, 能通信
v9: 多个 Agent, 能自治
```

每一步都在解决前一步暴露的瓶颈。v9 是这条线的终点——不是因为不能再加功能，而是因为 Agent 协作的基本元素已经齐全了：**共享状态（Tasks）+ 并行执行（Background）+ 通信（Messages）+ 自治（空闲循环 + 自动认领）**。

## 更深的洞察

> **一个能自我管理的团队。**

v8 的 Teammate 是同事：互相通信、共享看板、并行工作。但它们仍然等待明确指令。v9 的 Teammate 是自治的：自己找未认领的工作、认领它、执行它、回到待命状态。Team Lead 设定方向和创建任务，Teammate 自组织完成。

```sh
v8 Teammate -> 执行分配的工作，沟通结果（初级）
v9 Teammate -> 找活、领活、干活、待命（高级）
Team Lead   -> 拆任务，审核，协调（经理）
```

Agent 系统的终极形态不是一个更聪明的模型，而是**一群能协作和自组织的模型**。

---

**一个 Agent 能力有限，一群自治 Agent 无所不能。**

[← v8](./v8-团队通信.md) | [返回 README](../README_zh.md)
