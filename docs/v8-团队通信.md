# v8: 团队通信

**核心洞察：子代理是派出去的员工，Teammate 是坐在旁边的同事。**

v3 的子代理是"分而治之"：主代理派任务，子代理执行，返回结果，销毁。

```sh
v3 子代理：
  主代理 -> "去探索代码库" -> 子代理
  主代理 <- "auth 在 src/auth/" <- 子代理
  (子代理消失，上下文销毁)
```

对于"前端和后端同时开发"这样的任务，子代理不够用：不能互相通信、不能共享进度、执行完就销毁。Teammate 解决的是**持续性协作**问题。

## 五层概念架构

```sh
v8 Five Conceptual Layers:
+---------------------------------------------------+
| Layer 5: Teammate Loop                     ~70 LOC |
| work -> check inbox -> exit                        |
+---------------------------------------------------+
| Layer 4: Message Protocol                 ~120 LOC |
| 5 types: msg/broadcast/shutdown_req/resp/plan      |
+---------------------------------------------------+
| Layer 3: Inbox Infrastructure              ~60 LOC |
| JSONL per-teammate + lock file                     |
+---------------------------------------------------+
| Layer 2: Team Management                   ~80 LOC |
| create_team / delete_team / config.json            |
+---------------------------------------------------+
| Layer 1: Teammate Identity                 ~30 LOC |
| dataclass: agent_id, name, color, team_name        |
+---------------------------------------------------+
```

v8 的团队通信由五层构成：从底层的身份标识到顶层的工作循环，每层职责清晰，代码量可控。

## Subagent vs Teammate

| 特性 | Subagent (v3) | Teammate (v8) |
|------|--------------|---------------|
| 生命周期 | 一次性 | 持久性（创建、工作、关闭） |
| 通信 | 返回值（单向） | 消息协议（双向） |
| 并行 | 伪并行（等待返回） | 真并行（独立线程） |
| 任务管理 | 无 | 共享 Tasks (v6) |
| 适用场景 | 一次性任务 | 多模块长期协作 |

---

## Section A: 团队基础设施

### 架构

```sh
Team Lead（主代理）
  |-- Teammate: frontend   （守护线程）
  |-- Teammate: backend    （守护线程）
  +-- 共享:
        |-- .tasks/         <- 所有人看同一个看板
        +-- .teams/         <- 每个 Teammate 的 JSONL 收件箱
```

每个 Teammate 作为守护线程运行，有自己的 Agent 循环和上下文窗口，独立执行压缩（v5）。

### TeammateManager

`TeammateManager` 类管理团队生命周期和消息传递。它维护一个团队注册表，受线程锁保护：

```python
class TeammateManager:
    MESSAGE_TYPES = {
        "message", "broadcast", "shutdown_request",
        "shutdown_response", "plan_approval_response",
    }

    def __init__(self):
        self._teams: dict[str, dict[str, Teammate]] = {}
        self._lock = threading.Lock()
```

三个操作构成团队生命周期：
1. `create_team(name)` -- 注册新团队，创建目录
2. `spawn_teammate(name, team_name, prompt)` -- 启动 Teammate 线程
3. `delete_team(name)` -- 向所有成员发送关闭请求，移除团队

### Teammate 数据模型

```python
@dataclass
class Teammate:
    name: str
    team_name: str
    agent_id: str = ""       # 格式: "name@team_name"
    status: str = "active"   # active | shutdown
    thread: threading.Thread
    inbox_path: Path         # .teams/{team_name}/{name}_inbox.jsonl
    color: str = ""          # 终端输出的 ANSI 颜色
```

`agent_id` 字段使用 `name@team_name` 格式（如 `backend@rest-to-graphql`），在日志和消息中标识身份。

### Teammate 颜色

每个 Teammate 被分配一个不同的 ANSI 颜色用于终端输出，在 cyan、yellow、magenta、green、blue 之间循环。

```python
TEAMMATE_COLORS = [
    "\033[36m",   # cyan
    "\033[33m",   # yellow
    "\033[35m",   # magenta
    "\033[32m",   # green
    "\033[34m",   # blue
]
```

### 团队目录结构

```
.teams/
  rest-to-graphql/
    config.json             <- 团队元数据和成员列表
    frontend_inbox.jsonl    <- frontend Teammate 的收件箱
    frontend_inbox.lock     <- 原子写入的锁文件
    backend_inbox.jsonl     <- backend Teammate 的收件箱
    backend_inbox.lock
```

`config.json` 记录团队元数据和当前成员：

```json
{
  "name": "rest-to-graphql",
  "created_at": 1709234500.0,
  "members": [
    {"name": "frontend", "agent_id": "frontend@rest-to-graphql", "status": "active"},
    {"name": "backend", "agent_id": "backend@rest-to-graphql", "status": "active"}
  ]
}
```

---

## Section B: 消息协议

### 五种消息类型

| 消息类型 | 场景 | 方向 |
|---------|------|------|
| `message` | "后端 API 接口文档在 docs/api.md" | 点对点 |
| `broadcast` | "数据库 schema 已变更, 所有人注意" | 一对多 |
| `shutdown_request` | "项目完成了, 请收尾" | Lead -> Teammate |
| `shutdown_response` | "我这边已经收尾完毕" | Teammate -> Lead |
| `plan_approval_response` | "你的重构方案批准了, 执行吧" | Lead -> Teammate |

消息注入到 Teammate 对话时使用 `<teammate-message>` XML 格式：

```xml
<teammate-message teammate_id="{sender}" summary="{summary}">
{message text}
</teammate-message>
```

### JSONL 收件箱文件格式

每个 Teammate 在 `.teams/{team_name}/{name}_inbox.jsonl` 有专属收件箱文件。消息以 JSON 格式每行一条存储：

```json
{"type": "message", "sender": "lead", "content": "请先完成登录页面", "timestamp": 1709234567.89}
{"type": "broadcast", "sender": "backend", "content": "API schema 已定稿", "timestamp": 1709234590.12}
```

读取收件箱会消费所有消息并清空文件（读取即清空模式）。这防止了重复处理，同时保持格式简单且对并发写入友好。

### 收件箱锁文件

对收件箱文件的并发写入通过锁文件保护。`_write_to_inbox` 方法使用 `os.O_CREAT | os.O_EXCL` 实现原子锁获取：

```python
def _write_to_inbox(inbox_path, message):
    lock_path = inbox_path.with_suffix(".lock")
    for _ in range(50):   # 最多重试 50 次
        try:
            fd = os.open(str(lock_path), os.O_CREAT | os.O_EXCL | os.O_WRONLY)
            os.close(fd)
            break
        except FileExistsError:
            time.sleep(0.05)
    try:
        with open(inbox_path, "a") as f:
            f.write(json.dumps(message) + "\n")
    finally:
        lock_path.unlink(missing_ok=True)
```

`_write_to_inbox` 和 `check_inbox` 都使用此锁文件模式，防止并发读写之间的竞态条件。

### 广播的工作方式

广播不是独立的方法。它使用同一个 `send_message()` 函数，`msg_type="broadcast"`：

```python
SendMessage(recipient="anyone", content="Schema 已定稿", type="broadcast", team_name="my-project")
```

内部实现中，管理器遍历团队中所有 Teammate（排除发送者），将消息追加到每个 Teammate 的 JSONL 收件箱文件中。

---

## Section C: Teammate 工作循环

### TEAMMATE_TOOLS vs ALL_TOOLS

| 工具 | Team Lead | Teammate |
|------|-----------|----------|
| bash, read_file, write_file, edit_file | 有 | 有 |
| TaskCreate, TaskGet, TaskUpdate, TaskList | 有 | 有 |
| SendMessage | 有 | 有 |
| Task（生成子代理/Teammate） | 有 | 无 |
| Skill | 有 | 无 |
| TaskOutput, TaskStop | 有 | 无 |
| TeamCreate, TeamDelete | 有 | 无 |

Teammate 获得 9 个工具（4 BASE + 4 任务 CRUD + SendMessage）——足以完成工作、读取任务详情、更新共享看板、与同伴通信，但无法生成其他代理或管理团队本身。

### 三个核心工具

```python
# TeamCreate: 创建团队
TeamCreate(name="my-project")

# SendMessage: 发消息给 Teammate
SendMessage(recipient="frontend", content="请先完成登录页面")

# TeamDelete: 解散团队
TeamDelete(name="my-project")
```

Teammate 通过 Task 工具生成，指定 `team_name` 即可：

```python
Task(prompt="负责前端开发", team_name="my-project", name="frontend")
# -> 生成持久 Teammate，而非一次性子代理
```

同一个 Task 工具现在有三种模式：
1. 无额外参数 -- 同步子代理 (v3)
2. `run_in_background=True` -- 后台子代理 (v7)
3. `team_name + name` -- 持久 Teammate (v8)

### Teammate 工作循环

在 v8 中，Teammate 的循环很直接：接收提示词，工作直到完成，然后关闭。没有空闲循环或自动认领——这些在 v9 中引入。收件箱以 1 秒间隔轮询（匹配 cli.js cZz=1000ms）。

```python
def _teammate_loop(self, teammate, initial_prompt):
    sub_system = f"You are teammate '{teammate.name}' in team '{teammate.team_name}'..."
    sub_messages = [{"role": "user", "content": initial_prompt}]

    while teammate.status != "shutdown":
        teammate.status = "active"

        sub_messages = CTX.microcompact(sub_messages)
        if CTX.should_compact(sub_messages):
            sub_messages = CTX.auto_compact(sub_messages)

        response = client.messages.create(...)

        if response.stop_reason == "tool_use":
            # 执行工具并继续
            continue

        # 检查邮箱是否有新指令
        new_messages = self.check_inbox(teammate.name, teammate.team_name)
        if new_messages:
            if any(m.get("type") == "shutdown_request" for m in new_messages):
                return
            sub_messages.append({"role": "user", "content": format(new_messages)})
            continue

        # 没有更多工作
        return
```

---

## Section D: 完整生命周期

### 端到端流程

```sh
1. TeamCreate("rest-to-graphql")
   -> .teams/rest-to-graphql/ 创建
   -> config.json 初始化

2. Task(prompt="负责前端", team_name="rest-to-graphql", name="frontend")
   -> Teammate 作为守护线程生成
   -> frontend_inbox.jsonl 创建

3. Task(prompt="负责后端", team_name="rest-to-graphql", name="backend")
   -> 第二个 Teammate 生成

4. SendMessage(recipient="frontend", content="使用新的 API schema")
   -> 消息写入 frontend_inbox.jsonl（带锁）

5. Frontend Teammate 的循环：
   -> check_inbox() 读取并清空收件箱（带锁）
   -> 消息以 <teammate-message> XML 注入
   -> Teammate 处理并继续工作

6. SendMessage(type="broadcast", content="Schema 已定稿")
   -> 写入所有 Teammate 的收件箱

7. TeamDelete("rest-to-graphql")
   -> shutdown_request 发送给所有 Teammate
   -> 每个 Teammate 在下次收件箱检查时退出
   -> 团队从注册表中删除
```

### 关闭协议

1. **Team Lead** 通过 `SendMessage(type="shutdown_request")` 发送关闭请求
2. 消息写入 Teammate 的 JSONL 收件箱
3. Teammate 在下次检查邮箱时读取到 `shutdown_request`
4. Teammate 设置 `status = "shutdown"` 并退出循环
5. `TeamDelete` 同时向所有 Teammate 发送 `shutdown_request`，然后从注册表中删除团队

## 对比

| 方面 | v3 (Subagent) | v8 (Teammate) |
|------|--------------|---------------|
| 模型 | 一次性函数调用 | 持久性工作线程 |
| 通信 | 返回值 | 消息协议（5 种类型） |
| 状态 | 无状态 | 有状态（active/shutdown） |
| 任务管理 | 无 | 共享 Tasks |
| 并行 | 伪并行 | 真并行 |

## 更深的洞察

> **从命令到协作。**

v3 的子代理是命令模式：主代理发号施令，子代理服从执行。v8 的 Teammate 是协作模式：Team Lead 分配方向，Teammate 在共享任务上工作，通过邮箱互相沟通。

```sh
Subagent  -> 做一件事，回来汇报（实习生）
Teammate  -> 在分配的任务上工作，互相沟通（同事）
Team Lead -> 创建团队，分配工作，协调（经理）
```

下一步是让 Teammate 自主化：不再等待明确指令，而是自己找活干。这就是 v9。

---

**一个 Agent 能力有限，一群 Agent 大有可为。**

[← v7](./v7-后台任务与通知Bus.md) | [返回 README](../README_zh.md) | [v9 →](./v9-自治团队.md)
