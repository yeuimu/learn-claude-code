# v8: チーム通信

**コアの洞察: サブエージェントは派遣された作業員、チームメイトは隣に座る同僚。**

v3のサブエージェントは「分割統治」: タスクを与え、実行し、結果を返して消滅。

```sh
v3 サブエージェント:
  メインエージェント -> "コードベースを探索して" -> サブエージェント
  メインエージェント <- "authはsrc/auth/にある" <- サブエージェント
  （サブエージェント消滅、コンテキスト破棄）
```

「フロントエンドとバックエンドを同時に開発する」ようなタスクでは不十分: 互いに通信できない、進捗を共有できない、実行が終われば消滅する。チームメイトが解決するのは**持続的な協力**の問題。

## サブエージェント vs チームメイト

| 特徴 | サブエージェント (v3) | チームメイト (v8) |
|------|---------------------|-------------------|
| ライフサイクル | 一回限り | 持続的（生成、作業、シャットダウン） |
| 通信 | 戻り値（単方向） | メッセージプロトコル（双方向） |
| 並列性 | 疑似並列（返却待ち） | 真の並列（独立スレッド） |
| タスク管理 | なし | 共有Tasks (v6) |
| 適用場面 | 一回限りのタスク | 複数モジュールの長期協力 |

## 5つの概念レイヤー

v8は5つの独立したレイヤーで構成される：

```
+---------------------------------------------------+
|  Layer 5: ツールスコーピング                         |
|  Team Lead = 全ツール / Teammate = 制限ツール         |
+---------------------------------------------------+
|  Layer 4: メッセージプロトコル                        |
|  5種: message, broadcast, shutdown_req/resp,        |
|        plan_approval_response                       |
+---------------------------------------------------+
|  Layer 3: 受信箱アーキテクチャ                       |
|  JSONL per-teammate files + lock files              |
+---------------------------------------------------+
|  Layer 2: Teammateライフサイクル                     |
|  spawn -> work -> check inbox -> exit               |
+---------------------------------------------------+
|  Layer 1: TeammateManager                           |
|  create_team / spawn_teammate / delete_team         |
+---------------------------------------------------+
```

---

## Section A: チームインフラストラクチャ

### アーキテクチャ

```sh
Team Lead（メインエージェント）
  |-- Teammate: frontend   （デーモンスレッド）
  |-- Teammate: backend    （デーモンスレッド）
  +-- 共有:
        |-- .tasks/         <- 全員が同じボードを見る
        +-- .teams/         <- 各TeammateのJSONL受信箱
```

各Teammateはデーモンスレッドとして動作し、独自のエージェントループとコンテキストウィンドウを持ち、独立して圧縮（v5）を実行する。

### TeammateManager

`TeammateManager`クラスはチームのライフサイクルとメッセージングを管理する。スレッドロックで保護されたチームレジストリを維持:

```python
class TeammateManager:
    MESSAGE_TYPES = {
        "message", "broadcast", "shutdown_request",
        "shutdown_response", "plan_approval_response",
    }

    def __init__(self):
        self._teams: dict[str, dict[str, Teammate]] = {}
        self._lock = threading.Lock()
```

3つの操作がチームのライフサイクルを構成:
1. `create_team(name)` -- 新チームを登録、ディレクトリを作成
2. `spawn_teammate(name, team_name, prompt)` -- Teammateスレッドを開始
3. `delete_team(name)` -- 全メンバーにシャットダウンを送信、チームを削除

### Teammateデータモデル

```python
@dataclass
class Teammate:
    name: str
    team_name: str
    agent_id: str = ""       # フォーマット: "name@team_name"
    status: str = "active"   # active | shutdown
    thread: threading.Thread
    inbox_path: Path         # .teams/{team_name}/{name}_inbox.jsonl
    color: str = ""          # ターミナル出力用ANSIカラー
```

`agent_id`フィールドは `name@team_name` フォーマット（例: `backend@rest-to-graphql`）で、ログやメッセージでの識別に使用。

### Teammateカラー

各Teammateにはターミナル出力用に異なるANSIカラーが割り当てられ、cyan、yellow、magenta、green、blueを循環する。

```python
TEAMMATE_COLORS = [
    "\033[36m",   # cyan
    "\033[33m",   # yellow
    "\033[35m",   # magenta
    "\033[32m",   # green
    "\033[34m",   # blue
]
```

### チームディレクトリ構造

```
.teams/
  rest-to-graphql/
    config.json             <- チームメタデータとメンバーリスト
    frontend_inbox.jsonl    <- frontendTeammateの受信箱
    frontend_inbox.lock     <- アトミック書き込み用ロックファイル
    backend_inbox.jsonl     <- backendTeammateの受信箱
    backend_inbox.lock
```

`config.json`がチームのメタデータと現在のメンバーシップを記録:

```json
{
  "name": "rest-to-graphql",
  "created_at": 1709234500.0,
  "members": [
    {"name": "frontend", "agent_id": "frontend@rest-to-graphql", "status": "active"},
    {"name": "backend", "agent_id": "backend@rest-to-graphql", "status": "active"}
  ]
}
```

---

## Section B: メッセージプロトコル

### 5種類のメッセージタイプ

| メッセージタイプ | シナリオ | 方向 |
|-----------------|---------|------|
| `message` | "APIドキュメントはdocs/api.mdにある" | ポイントツーポイント |
| `broadcast` | "DBスキーマが変更、全員注意" | 一対多 |
| `shutdown_request` | "プロジェクト完了、まとめてください" | Lead -> Teammate |
| `shutdown_response` | "こちらはまとめ完了" | Teammate -> Lead |
| `plan_approval_response` | "リファクタリング計画を承認" | Lead -> Teammate |

メッセージがTeammateの対話に注入される際は `<teammate-message>` XML形式を使用:

```xml
<teammate-message teammate_id="{sender}" summary="{summary}">
{message text}
</teammate-message>
```

### JSONL受信箱のファイル形式

各Teammateは `.teams/{team_name}/{name}_inbox.jsonl` に専用の受信箱ファイルを持つ。メッセージはJSON形式で1行に1つずつ格納:

```json
{"type": "message", "sender": "lead", "content": "まずログインページを完成させてください", "timestamp": 1709234567.89}
{"type": "broadcast", "sender": "backend", "content": "APIスキーマが確定した", "timestamp": 1709234590.12}
```

受信箱の読み取りは全メッセージを消費しファイルをクリアする（読み取り即クリアパターン）。

### 受信箱ロックファイル

受信箱ファイルへの並行書き込みはロックファイルで保護される。`_write_to_inbox`メソッドは `os.O_CREAT | os.O_EXCL` でアトミックなロック取得を行う:

```python
def _write_to_inbox(inbox_path, message):
    lock_path = inbox_path.with_suffix(".lock")
    for _ in range(50):   # 最大50回リトライ
        try:
            fd = os.open(str(lock_path), os.O_CREAT | os.O_EXCL | os.O_WRONLY)
            os.close(fd)
            break
        except FileExistsError:
            time.sleep(0.05)
    try:
        with open(inbox_path, "a") as f:
            f.write(json.dumps(message) + "\n")
    finally:
        lock_path.unlink(missing_ok=True)
```

`_write_to_inbox` と `check_inbox` の両方がこのロックファイルパターンを使用し、並行読み書き間の競合状態を防ぐ。

### ブロードキャストの仕組み

ブロードキャストは独立したメソッドではない。同じ `send_message()` 関数を `msg_type="broadcast"` で使用する:

```python
SendMessage(recipient="anyone", content="スキーマが確定した", type="broadcast", team_name="my-project")
```

内部では、マネージャーがチーム内の全Teammate（送信者を除く）を巡回し、各TeammateのJSONL受信箱ファイルにメッセージを追記する。

---

## Section C: Teammateの作業ループ

### TEAMMATE_TOOLS vs ALL_TOOLS

| ツール | Team Lead | Teammate |
|--------|-----------|----------|
| bash, read_file, write_file, edit_file | あり | あり |
| TaskCreate, TaskGet, TaskUpdate, TaskList | あり | あり |
| SendMessage | あり | あり |
| Task（サブエージェント/Teammateの生成） | あり | なし |
| Skill | あり | なし |
| TaskOutput, TaskStop | あり | なし |
| TeamCreate, TeamDelete | あり | なし |

Teammateは9ツール（4 BASE + 4タスクCRUD + SendMessage）を受け取る。作業の実行、タスク詳細の読み取り、共有ボードの更新、仲間との通信には十分だが、他のエージェントの生成やチーム自体の管理はできない。

### 3つのコアツール

```python
# TeamCreate: チームを作成
TeamCreate(name="my-project")

# SendMessage: Teammateにメッセージを送信
SendMessage(recipient="frontend", content="まずログインページを完成させてください")

# TeamDelete: チームを解散
TeamDelete(name="my-project")
```

TeammateはTaskツールで生成し、`team_name`を指定する:

```python
Task(prompt="フロントエンド開発を担当", team_name="my-project", name="frontend")
# -> 一回限りのサブエージェントではなく、持続的なTeammateを生成
```

同じTaskツールに3つのモード:
1. 追加パラメータなし -- 同期サブエージェント (v3)
2. `run_in_background=True` -- バックグラウンドサブエージェント (v7)
3. `team_name + name` -- 持続的なTeammate (v8)

### Teammateの作業ループ

v8では、Teammateのループはシンプル: プロンプトを受け取り、作業が終わるまで実行し、シャットダウンする。アイドルサイクルや自動割当はない -- それらはv9で導入。受信箱は1秒間隔でポーリング（cli.js cZz=1000msに一致）。

```python
def _teammate_loop(self, teammate, initial_prompt):
    sub_system = f"You are teammate '{teammate.name}' in team '{teammate.team_name}'..."
    sub_messages = [{"role": "user", "content": initial_prompt}]

    while teammate.status != "shutdown":
        teammate.status = "active"

        sub_messages = CTX.microcompact(sub_messages)
        if CTX.should_compact(sub_messages):
            sub_messages = CTX.auto_compact(sub_messages)

        response = client.messages.create(...)

        if response.stop_reason == "tool_use":
            # ツールを実行して続行
            continue

        # 受信箱に新しい指示があるか確認
        new_messages = self.check_inbox(teammate.name, teammate.team_name)
        if new_messages:
            if any(m.get("type") == "shutdown_request" for m in new_messages):
                return
            sub_messages.append({"role": "user", "content": format(new_messages)})
            continue

        # 残りの作業なし
        return
```

---

## Section D: 完全なライフサイクル

### エンドツーエンドのウォークスルー

```sh
1. TeamCreate("rest-to-graphql")
   -> .teams/rest-to-graphql/ 作成
   -> config.json 初期化

2. Task(prompt="フロントエンドを担当", team_name="rest-to-graphql", name="frontend")
   -> Teammateがデーモンスレッドとして生成
   -> frontend_inbox.jsonl 作成

3. Task(prompt="バックエンドを担当", team_name="rest-to-graphql", name="backend")
   -> 2番目のTeammateが生成

4. SendMessage(recipient="frontend", content="新しいAPIスキーマを使用してください")
   -> メッセージがfrontend_inbox.jsonlに書き込み（ロック付き）

5. Frontend Teammateのループ:
   -> check_inbox() が受信箱を読み取りクリア（ロック付き）
   -> メッセージが <teammate-message> XMLとして注入
   -> Teammateが処理して作業を続行

6. SendMessage(type="broadcast", content="スキーマ確定")
   -> 全Teammateの受信箱に書き込み

7. TeamDelete("rest-to-graphql")
   -> shutdown_requestが全Teammateに送信
   -> 各Teammateが次の受信箱チェックで終了
   -> チームがレジストリから削除
```

### シャットダウンプロトコル

1. **Team Lead**が `SendMessage(type="shutdown_request")` でシャットダウン要求を送信
2. メッセージがTeammateのJSONL受信箱に書き込まれる
3. Teammateが次の受信箱チェックで `shutdown_request` を読み取る
4. Teammateが `status = "shutdown"` を設定しループを終了
5. `TeamDelete` はチーム内の全Teammateに同時に `shutdown_request` を送信し、レジストリからチームを削除

## 比較

| 側面 | v3 (サブエージェント) | v8 (チームメイト) |
|------|---------------------|-------------------|
| モデル | 一回限りの関数呼び出し | 持続的なワーカースレッド |
| 通信 | 戻り値 | メッセージプロトコル（5種） |
| 状態 | ステートレス | ステートフル（active/shutdown） |
| タスク管理 | なし | 共有Tasks |
| 並列性 | 疑似並列 | 真の並列 |

## より深い洞察

> **命令から協力へ。**

v3のサブエージェントはコマンドモデル: メインエージェントが命令し、サブエージェントが従う。v8のチームメイトは協力モデル: Team Leadが方向を割り当て、Teammateが共有タスクで作業し、受信箱を通じて互いに通信する。

```sh
サブエージェント -> 1つのことをして、報告に戻る（インターン）
チームメイト    -> 割り当てられたタスクで作業し、通信する（同僚）
Team Lead      -> チームを作成し、作業を割り当て、調整する（マネージャー）
```

次のステップはチームメイトの自律化: 明示的な指示を待つのではなく、自分で仕事を見つける。それがv9。

---

**1つのエージェントの能力には限界がある。エージェントのチームには大きな可能性がある。**

[← v7](./v7-バックグラウンドタスク.md) | [READMEに戻る](../README_ja.md) | [v9 →](./v9-自律チーム.md)
