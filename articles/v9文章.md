# mini Claude Code v9：自治团队 -- Agent 系统的终极形态

v8 给了 Agent 团队通信的能力：消息邮箱、广播、关闭协议。但 v8 的 Teammate 本质上还是"被动同事"——给了任务就干，干完就退出。

v9 补上最后一环：**Teammate 自治**。它们不再等命令，而是自己找活干。

## 1. 自治的三个要素

v9 在 v8 的基础上新增三个核心机制：

```sh
空闲循环      Teammate 工作完成后不退出，进入 idle 状态
              每 1 秒检查邮箱和任务看板，持续 60 秒
              发现新消息或未认领任务就唤醒

任务自动认领  idle 时扫描看板，发现 pending + 无 owner + 无 blocker 的任务
              自动设为 in_progress，设置 owner = 自己
              先到先得，线程锁防竞态

身份保持      上下文压缩后，Teammate 可能"忘记"自己是谁
              循环中检测压缩，在压缩摘要后追加身份信息
              "Remember: You are teammate 'backend' in team 'rest-to-graphql'"
```

## 2. 完整的 Teammate 状态机

```sh
  +--------+      工作完成       +------+
  | active | ----------------> | idle |
  +--------+                   +------+
      ^                           |
      |     收到新消息/发现新任务    |
      +---------------------------+

  任何状态 -- shutdown_request --> [shutdown]
```

关键区别：
- **v8**: active -> 完成 -> 退出
- **v9**: active -> 完成 -> idle -> (发现新工作) -> active -> ...

## 3. _idle_phase 详细走读

`_idle_phase` 是 v9 新增的核心方法，实现了 Teammate 的空闲等待和自动唤醒逻辑：

```python
# v9_autonomous_agent.py 行 465-494
def _idle_phase(self, teammate: Teammate, sub_messages: list) -> str:
    """Poll for new messages and unclaimed tasks during idle.
    Returns: "resume" (new work), "shutdown" (requested), or "timeout" (expired)."""

    # 1. 进入 idle 状态，记录原因
    teammate.status = "idle"
    teammate.idle_reason = IDLE_REASONS["no_tool_use"]

    # 2. 计算轮询次数: 60s / 2s = 30 次
    polls = IDLE_TIMEOUT // IDLE_POLL_INTERVAL    # 60 // 2 = 30

    for i in range(polls):
        # 3. 外部可能已设置 shutdown
        if teammate.status == "shutdown":
            return "shutdown"

        # 4. 检查收件箱
        teammate.idle_reason = IDLE_REASONS["awaiting_messages"]
        new_messages = self.check_inbox(teammate.name, teammate.team_name)
        if new_messages:
            result = self._handle_inbox_messages(teammate, new_messages, sub_messages)
            if result == "shutdown":
                return "shutdown"        # shutdown_request 收到
            return "resume"              # 有新消息 -> 唤醒

        # 5. 扫描未认领任务
        teammate.idle_reason = IDLE_REASONS["awaiting_tasks"]
        claimed = self._scan_unclaimed_tasks(teammate, sub_messages)
        if claimed:
            return "resume"              # 认领成功 -> 唤醒

        # 6. 本轮无事，等 2 秒
        time.sleep(IDLE_POLL_INTERVAL)

    # 7. 30 轮全部跑完，仍无新工作
    teammate.idle_reason = IDLE_REASONS["timeout"]
    return "timeout"                     # 超时 -> 关闭
```

返回值的语义：
- `"resume"`: 发现新工作（消息或任务），调用方回到 active 阶段继续循环
- `"shutdown"`: 收到 `shutdown_request`，调用方直接退出
- `"timeout"`: 60 秒内无任何新工作，调用方优雅关闭

`_idle_phase` 在 `_teammate_loop` 中的调用位置：

```python
# active 阶段结束后（stop_reason != "tool_use" 或异常）
idle_result = self._idle_phase(teammate, sub_messages)
if idle_result == "shutdown":
    return
elif idle_result == "timeout":
    teammate.status = "shutdown"
    self._update_team_config(teammate.team_name)
    return
# else: "resume" -> while 循环继续
```

## 4. _scan_unclaimed_tasks + _claim_task 走读

任务自动认领分为两步：扫描和认领。

```python
# v9_autonomous_agent.py 行 529-544
def _scan_unclaimed_tasks(self, teammate: Teammate, sub_messages: list) -> bool:
    """Scan the task board for unclaimed tasks. Returns True if a task was claimed."""
    unclaimed = [t for t in TASK_MGR.list_all()
                 if t.status == "pending"       # 状态为 pending
                 and not t.owner                # 没有 owner
                 and not t.blocked_by]          # 没有未完成的依赖
    if not unclaimed:
        return False
    return self._claim_task(teammate, unclaimed[0], sub_messages)

def _claim_task(self, teammate: Teammate, task, sub_messages: list) -> bool:
    """Claim a task and inject it into conversation for the teammate to work on."""
    # 原子操作：同时设置 status 和 owner
    TASK_MGR.update(task.id, status="in_progress", owner=teammate.name)

    # 将任务内容作为新的 user 消息注入对话
    sub_messages.append({
        "role": "user",
        "content": f"Unclaimed task auto-claimed - #{task.id}: {task.subject}\n\n{task.description}"
    })
    return True
```

认领的三个安全保障：
1. **过滤条件**：`pending + 无 owner + 无 blocked_by`，确保只认领可执行的任务
2. **先到先得**：`unclaimed[0]` 按 ID 排序取第一个，多个 Teammate 自然分散
3. **线程锁**：`TASK_MGR.update()` 内部使用 `threading.Lock`，防止两个 Teammate 同时认领同一任务

注意 `_scan_unclaimed_tasks` 和 `_claim_task` 是分开的方法。这是有意设计：扫描是只读的查询，认领是写入操作，分离使逻辑清晰且方便测试。

## 5. _reinject_identity 走读

上下文压缩后身份丢失是一个微妙问题。`auto_compact` 生成的摘要是对话内容的提炼，不包含 system prompt 中的身份信息。虽然 system prompt 本身会在每次 API 调用中发送，但压缩摘要中缺少身份上下文会导致模型在后续对话中混淆角色。

```python
# v9_autonomous_agent.py 行 546-554
@staticmethod
def _reinject_identity(teammate: 'Teammate', sub_messages: list):
    """After auto_compact, re-inject teammate identity so it remembers who it is."""
    identity = (f"\n\nRemember: You are teammate '{teammate.name}' "
                f"({teammate.agent_id}) in team '{teammate.team_name}'.")

    # 追加到第一条 user 消息（即压缩摘要）
    if sub_messages and sub_messages[0].get("role") == "user":
        content = sub_messages[0].get("content", "")
        if isinstance(content, str):
            sub_messages[0]["content"] = content + identity
```

为什么追加到 `sub_messages[0]`：`auto_compact` 返回的消息列表中，第一条消息是 `[Conversation compressed]\n\n{summary}`。身份信息追加到这条摘要的末尾，确保模型在读到压缩上下文时同时获得身份提醒。

调用位置：

```python
# v9_autonomous_agent.py _teammate_loop 中
if CTX.should_compact(sub_messages):
    sub_messages = CTX.auto_compact(sub_messages)
    self._reinject_identity(teammate, sub_messages)  # 压缩后立即注入
```

设计为 `@staticmethod`，因为它不访问 `TeammateManager` 的状态，只操作传入的参数。

## 6. IDLE_REASONS 常量与调试

v9 引入了 `IDLE_REASONS` 字典，为 Teammate 的每种空闲状态提供可读的描述：

```python
# v9_autonomous_agent.py 行 128-133
IDLE_REASONS = {
    "no_tool_use":        "Model returned without tool calls",
    "awaiting_messages":  "Polling inbox for new messages",
    "awaiting_tasks":     "Scanning board for unclaimed tasks",
    "timeout":            "Idle timeout expired with no new work",
}
```

`idle_reason` 在 `_idle_phase` 的每个阶段被更新，用于调试和日志：

| idle_reason 值 | 设置时机 | 含义 |
|---------------|---------|------|
| `no_tool_use` | 刚进入 idle 阶段 | 模型停止了工具调用 |
| `awaiting_messages` | 即将检查收件箱 | 正在等待新消息 |
| `awaiting_tasks` | 即将扫描任务看板 | 正在寻找可认领任务 |
| `timeout` | 30 轮循环结束 | 60 秒内无新工作 |

`idle_reason` 存储在 `Teammate.idle_reason` 字段中（v8 的 `Teammate` 没有这个字段）。可以通过 `get_team_status()` 查看每个 Teammate 当前的空闲原因，方便调试"为什么这个 Teammate 没在工作"的问题。

相关配置常量：

```python
IDLE_POLL_INTERVAL = 1     # 每次轮询间隔 1 秒 (cli.js cZz=1000ms)
IDLE_TIMEOUT = 60          # 总超时 60 秒
# 轮询次数 = 60 / 1 = 60 次
```

## 7. 计划审批协议走读

v9 完整实现了 `plan_approval_response` 消息类型的处理。当 Teammate 需要对重大变更获得批准时，使用以下流程：

```sh
Teammate                     Team Lead
    |                            |
    |  SendMessage("plan...")    |
    |  type="message"            |
    +--------------------------->|
    |                            |
    |                    审核计划  |
    |                            |
    |  plan_approval_response    |
    |  approve=true/false        |
    |<---------------------------+
    |                            |
    v                            |
处理审批结果:                      |
  approved -> "Plan APPROVED."    |
  rejected -> "Plan REJECTED: {feedback}"
```

具体代码实现：

```python
# v9_autonomous_agent.py 行 496-511
def _handle_inbox_messages(self, teammate, messages, sub_messages):
    for msg in messages:
        msg_type = msg.get("type", "message")

        # shutdown_request -> 立即退出
        if msg_type == "shutdown_request":
            teammate.status = "shutdown"
            self._update_team_config(teammate.team_name)
            return "shutdown"

        # plan_approval_response -> 解析审批结果
        if msg_type == "plan_approval_response":
            approved = msg.get("approved", False)
            feedback = msg.get("content", "")
            approval_text = ("Plan APPROVED." if approved
                             else f"Plan REJECTED: {feedback}")
            sub_messages.append({"role": "user", "content": approval_text})
            return None  # 不触发 shutdown，继续工作

    # 普通消息 -> 格式化为 XML 注入对话
    msg_text = "\n".join(
        f'<teammate-message sender="{m.get("sender", "?")}" '
        f'type="{m.get("type", "message")}">\n'
        f'{m.get("content", "")}\n</teammate-message>'
        for m in messages
    )
    sub_messages.append({"role": "user", "content": msg_text})
    return None
```

审批协议的关键：它是纯消息协议，不需要专门的工具。Teammate 通过普通 `SendMessage` 发送计划详情，Team Lead 通过 `SendMessage(type="plan_approval_response")` 回复。Teammate 在下一次 `check_inbox` 时读取到审批结果。

## 8. 完整协作流程

```sh
用户: "把应用从 REST 迁移到 GraphQL"

Team Lead:
  1. TeamCreate("rest-to-graphql")
  2. TaskCreate("Analyze REST endpoints")              -> #1
     TaskCreate("Design GraphQL schema")               -> #2, blockedBy=#1
     TaskCreate("Implement resolvers")                  -> #3, blockedBy=#2
     TaskCreate("Update frontend queries")              -> #4, blockedBy=#3

  3. Task(name="analyst",  team_name=..., prompt="分析 REST 端点")
     Task(name="backend",  team_name=..., prompt="处理后端迁移")
     Task(name="frontend", team_name=..., prompt="处理前端更新")

执行过程:

  analyst:  看到 #1 -> 认领 -> 执行 -> 完成 -> idle
                                                   |
  backend:  空闲中... <--- #2 解锁 ---------------+
            认领 #2 -> 完成 -> 认领 #3 -> 完成 -> idle
                                                     |
  frontend: 空闲中... <--- #4 解锁 -----------------+
            认领 #4 -> 执行 -> 完成 -> idle

  Team Lead: 收到通知 -> 所有任务完成
             TeamDelete("rest-to-graphql")
```

注意 Team Lead **没有**手动分配任务给具体的 Teammate。它只创建了任务和 Teammate，剩下的由 Teammate 自组织完成。

## 9. 四个机制联动

| 机制 | 角色 | 比喻 |
|------|------|------|
| Tasks (v6) | 共享看板 | 办公室白板，所有人看同一个 |
| Background (v7) | 并行执行 | 每人一张桌子，同时干活 |
| Messages (v8) | 点对点通信 | 同事之间直接对话 |
| Autonomy (v9) | 自组织 | 没人分配，自己找活干 |

缺少任何一个，协作都不完整。

## 10. v0 到 v9 完整回顾

| 版本 | 核心主题 | 行数 | 关键洞察 |
|------|----------|------|----------|
| v0 | Bash is All | ~196 | 一个工具 + 递归 = 完整 Agent |
| v1 | Model as Agent | ~417 | 模型是 80%，代码是工具循环 |
| v2 | 结构化规划 | ~531 | Todo 让计划可见 |
| v3 | 分而治之 | ~623 | 子代理隔离上下文 |
| v4 | 领域专家 | ~783 | Skills 注入知识 |
| v5 | 永不遗忘 | ~896 | 三层压缩模拟记忆 |
| v6 | 团队看板 | ~957 | Tasks 替代 Todo |
| v7 | 并行执行 | ~1022 | 后台任务 + 通知 Bus |
| v8 | 团队通信 | ~1402 | Teammate 消息协议 |
| **v9** | **自治团队** | **~1506** | **空闲循环 + 自动认领** |

十个版本，从 16 行到约 1506 行 Python，覆盖了从单 Agent 到自组织多 Agent 团队的完整设计。

## 11. 更深的洞察

v0 到 v9 的演进讲了一个完整的故事：

```sh
v0: 一个 Agent, 一个工具
v1: 一个 Agent, 多个工具
v2: 一个 Agent, 有计划
v3: 一个 Agent, 能派人
v4: 一个 Agent, 有知识
v5: 一个 Agent, 能遗忘
v6: 多个 Agent, 有看板
v7: 多个 Agent, 能并行
v8: 多个 Agent, 能通信
v9: 多个 Agent, 能自治
```

每一步都在解决前一步暴露的瓶颈。v9 是终点——不是因为不能再加功能，而是因为 Agent 协作的基本元素已经齐全了：**共享状态 + 并行执行 + 双向通信 + 自治能力**。

更深层的洞察是：**Agent 系统的终极形态不是一个更聪明的模型，而是一群能协作和自组织的模型。** 人类文明的复杂性也不是来自单个大脑的进化，而是来自协作机制的进化：语言、文字、组织、制度。

---

**一个 Agent 能力有限，一群自治 Agent 无所不能。Agent 系统的进化不是让个体更强，而是让群体更协调。**

完整代码见仓库 `v9_autonomous_agent.py`。
